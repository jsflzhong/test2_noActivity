1.活动状态
    每个活动在其生命周期中最多可能会有4种状态。
    01. 运行状态
        当一个活动位于返回栈的栈顶时，这时活动就处于运行状态。系统最不愿意回收的就是处
        于运行状态的活动，因为这会带来非常差的用户体验。
    02. 暂停状态
        当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态。你可能会觉
        得既然活动已经不在栈顶了，还怎么会可见呢？这是因为并不是每一个活动都会占满整个
        屏幕的，比如对话框形式的活动只会占用屏幕中间的部分区域，你很快就会在后面看到这
        种活动。处于暂停状态的活动仍然是完全存活着的，系统也不愿意去回收这种活动（因为
        它还是可见的，回收可见的东西都会在用户体验方面有不好的影响），只有在内存极低的
        情况下，系统才会去考虑回收这种活动。
    03. 停止状态
        当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会
        为这种活动保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存
        时，处于停止状态的活动有可能会被系统回收。
    04. 销毁状态
        当一个活动从返回栈中移除后就变成了销毁状态。系统会最倾向于回收处于这种状态的活
        动，从而保证手机的内存充足。

2.活动的生存期
      Activity类中定义了7个回调方法，覆盖了活动生命周期的每一个环节，下面就来一一介绍这7个
      方法。
      onCreate() 。
          这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它
          会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说
          加载布局、绑定事件等。
      onStart() 。
          这个方法在活动由不可见变为可见的时候调用。
      onResume() 。
          这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于
          返回栈的栈顶，并且处于运行状态。
      onPause() 。
          这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在
          这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速
          度一定要快，不然会影响到新的栈顶活动的使用。
      onStop() 。
          这个方法在活动完全不可见的时候调用。它和onPause() 方法的主要区别在
          于，如果启动的新活动是一个对话框式的活动，那么onPause() 方法会得到执行，
          而onStop() 方法并不会执行。
      onDestroy() 。
          这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。
      onRestart() 。
          这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。

      以上7个方法中除了onRestart() 方法，其他都是两两相对的，从而又可以将活动分为3种生存期。

      完整生存期 。
          活动在onCreate() 方法和onDestroy() 方法之间所经历的，就是完整生
          存期。一般情况下，一个活动会在onCreate() 方法中完成各种初始化操作，而
          在onDestroy() 方法中完成释放内存的操作。
      可见生存期 。
          活动在onStart() 方法和onStop() 方法之间所经历的，就是可见生存
          期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们
          可以通过这两个方法，合理地管理那些对用户可见的资源。比如在onStart() 方法中对资
          源进行加载，而在onStop() 方法中对资源进行释放，从而保证处于停止状态的活动不会
          占用过多内存。
      前台生存期 。
          活动在onResume() 方法和onPause() 方法之间所经历的就是前台生存
          期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行交互的，
          我们平时看到和接触最多的也就是这个状态下的活动。

3.活动的启动模式
    活动的启动模式对你来说应该是个全新的概念，在实际项目中我们应该根据特定的需求为每个
    活动指定恰当的启动模式。
    启动模式一共有4种，分别是standard(默认)、singleTop、singleTask和singleInstance，
    可以在AndroidManifest.xml中通过给<activity> 标签指定android:launchMode 属性来选择启动模式.

    3.1.standard 模式
        对于使用standard模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例.
        缺点:可能在有些情况下，你会觉得standard模式不太合理。活动明明已经在栈顶了，为什么再次启动的时候还要创建一个新的活动实例呢？

    3.2.singleTop 模式
        当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的"栈顶"已经是该活动(只针对栈顶!!),
        则认为可以直接使用它，不会再创建新的活动实例。
        缺点:如果该活动并没有处于栈顶的位置，还是可能会创建多个活动实例的

    3.3.singleTask 模式
        有没有什么办法可以让某个活动在整个应用程序的上下文中只存在一个实例呢？
        这就要借助singleTask模式来实现了。
        当活动的启动模式指定为singleTask，每次启动该活动时系统首先会在返回栈中检查是否存
        在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统
        出栈，如果没有发现就会创建一个新的活动实例。

    3.4.singleInstance模式
        不同于以上3种启动模式，指定为singleInstance模式的活动会启用一个新的返回栈
        来管理这个活动（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回
        栈）。那么这样做有什么意义呢？想象以下场景，假设我们的程序中有一个活动是允许其他程
        序调用的，如果我们想实现其他程序和我们的程序可以共享这个活动的实例，应该如何实现
        呢？使用前面3种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个活
        动在不同的返回栈中入栈时必然是创建了新的实例。而使用singleInstance模式就可以解决这个问
        题，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活
        动，都共用的同一个返回栈，也就解决了共享活动实例的问题。

4.4种基本布局
    4.1.线性布局
        LinearLayout又称作线性布局，是一种非常常用的布局。正如它的名字所描述的一样，这个布局
        会将它所包含的控件在线性方向上依次排列.
    4.2.相对布局
        RelativeLayout又称作相对布局，也是一种非常常用的布局。和LinearLayout的排列规则不同，
        RelativeLayout显得更加随意一些，它可以通过相对定位的方式让控件出现在布局的任何位置
    4.3.帧布局
        FrameLayout又称作帧布局，它相比于前面两种布局就简单太多了，因此它的应用场景也少了很
        多。这种布局没有方便的定位方式，所有的控件都会默认摆放在布局的左上角
    4.4.百分比布局
        在这种布局中，我们可以不再使用wrap_content 、match_parent 等方式来指定控件的大小，
        而是允许直接指定控件在布局中所占的百分比，
        这样的话就可以轻松实现平分布局甚至是任意比例分割布局的效果了。
        打开app/build.gradle文件，在dependencies 闭包中添加如下内容：
            dependencies {
            implementation 'androidx.percentlayout:percentlayout:1.0.0'
            }

5.在布局中引用其他布局.
    使用include即可.注意要在LinearLayout节点层级的下层.
    例子见: title.xml和first_layout.xml

6.自定义控件.
    TitleLayout.java
